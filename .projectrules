# .projectrules - BDD Agent Specific Patterns

**Inicializado**: 2025-08-27 16:19:05  
**Projeto**: BDD Agent - Sistema Python para geraÃ§Ã£o de BDD com IA  
**Desenvolvedor**: Rafael Pelizza (PelizzAI)

---

## ğŸ¯ **PadrÃµes EspecÃ­ficos do Projeto BDD Agent**

### **Arquitetura e Estrutura**

#### **OrganizaÃ§Ã£o Modular Descoberta**
```python
# PadrÃ£o: SeparaÃ§Ã£o clara entre apresentaÃ§Ã£o, lÃ³gica e integraÃ§Ã£o
src/
â”œâ”€â”€ main.py                 # âœ… Entry point - Streamlit UI only
â”œâ”€â”€ bdd_generator/         # âœ… Core business logic
â”‚   â”œâ”€â”€ generator.py       # âœ… BDD orchestration
â”‚   â””â”€â”€ openai_client.py   # âœ… External API wrapper
â”œâ”€â”€ [auth|config|ui|utils]/ # ğŸ“‹ Placeholders bem organizados
```

#### **Responsabilidades Bem Definidas**
- **main.py**: APENAS interface Streamlit, delegaÃ§Ã£o para core
- **generator.py**: APENAS orquestraÃ§Ã£o BDD, nÃ£o conhece UI
- **openai_client.py**: APENAS comunicaÃ§Ã£o API, nÃ£o conhece negÃ³cio

### **PadrÃµes OpenAI Integration**

#### **API Key Validation Pattern**
```python
# PadrÃ£o especÃ­fico descoberto: validaÃ§Ã£o sk- + length
def _validate_api_key_format(self, api_key: str) -> bool:
    cleaned_key = api_key.strip()
    return cleaned_key.startswith('sk-') and len(cleaned_key) >= 20

# UI: ValidaÃ§Ã£o em tempo real + feedback visual
if cleaned_key.startswith('sk-') and len(cleaned_key) >= 20:
    st.success("âœ… API Key configurada")
else:
    st.error("âŒ Formato de API Key invÃ¡lido")
```

#### **Model Configuration Strategy**
```python
# PadrÃ£o: Modelos hardcoded com metadata rico
SUPPORTED_MODELS = {
    "gpt-4o-mini": {"name": "GPT-4o Mini", "max_tokens": 4096, "cost_per_1k": 0.00015},
    "gpt-4.1-mini": {"name": "GPT-4.1 Mini", "max_tokens": 4096, "cost_per_1k": 0.0001},
    # Novos modelos incluindo versÃµes futuras gpt-5-mini, gpt-4.1-nano
}
```

#### **Error Handling + Logging Pattern**
```python
# PadrÃ£o: Try-catch com logging estruturado + re-raise
try:
    response = self.client.chat.completions.create(...)
    logger.info(f"Tokens usados - Prompt: {usage.prompt_tokens}")
except Exception as e:
    logger.error(f"Erro na API OpenAI: {str(e)}")
    raise  # Always re-raise for caller handling
```

### **Streamlit UI Patterns**

#### **Layout Pattern Descoberto**
```python
# PadrÃ£o: Sidebar para config + main em colunas
with st.sidebar:
    # ConfiguraÃ§Ãµes IA, validaÃ§Ãµes
    
col1, col2 = st.columns([1, 1])
with col1:
    # Input do usuÃ¡rio
with col2:
    # Output/resultados
```

#### **State Management Pattern**
```python
# PadrÃ£o: session_state para configuraÃ§Ãµes + validaÃ§Ã£o condicional
config = {
    "incluir_negativos": st.session_state.get("incluir_negativos", True),
    "casos_extremos": st.session_state.get("casos_extremos", False),
    "num_cenarios": st.session_state.get("num_cenarios", 3),
}
```

#### **Feedback Visual Pattern**
```python
# PadrÃ£o: Loading + Success/Error com contexto
with st.spinner("ğŸ¤– Gerando cenÃ¡rios BDD..."):
    # Processing
    
if success:
    st.success("âœ… CenÃ¡rios gerados com sucesso!")
    st.markdown(result)
else:
    st.error(f"âŒ Erro na geraÃ§Ã£o: {str(e)}")
```

### **BDD-Specific Patterns**

#### **Gherkin Template Strategy**
```python
# PadrÃ£o: Template system prompt em portuguÃªs + user prompt dinÃ¢mico
system_prompt = """
VocÃª Ã© um especialista em BDD...
Regras importantes:
1. Use SEMPRE portuguÃªs brasileiro
2. Siga a estrutura: Funcionalidade, CenÃ¡rio, Dado, Quando, EntÃ£o, E
"""

user_prompt = f"""Gere {num_scenarios} cenÃ¡rios BDD para:
{user_story}
[ConfiguraÃ§Ãµes dinÃ¢micas baseadas em flags]
"""
```

#### **Scenario Classification Logic**
```python
# PadrÃ£o: Keyword-based classification
negative_keywords = ["erro", "invÃ¡lido", "falha", "negativo", "incorreto"]
edge_keywords = ["limite", "extremo", "mÃ¡ximo", "mÃ­nimo", "vazio"]

# Busca em title + steps para classificaÃ§Ã£o automÃ¡tica
```

#### **Parsing Strategy**
```python
# PadrÃ£o: Line-by-line parsing com state machine
current_scenario = None
current_steps = []

for line in lines:
    if line.startswith("CenÃ¡rio:"):
        # Save previous, start new
    elif line.startswith(("Dado", "Quando", "EntÃ£o", "E", "Mas")):
        current_steps.append(line)
```

### **Quality Patterns EspecÃ­ficos**

#### **Python Version Constraint**
```toml
# PadrÃ£o especÃ­fico: ExclusÃ£o da versÃ£o 3.9.7
python = ">=3.9,<3.9.7 || >3.9.7,<4.0"
# RazÃ£o: PossÃ­vel incompatibilidade conhecida
```

#### **Pydantic Model Pattern**
```python
# PadrÃ£o: Field descriptions em portuguÃªs para self-documentation
class BDDScenario(BaseModel):
    title: str = Field(..., description="TÃ­tulo do cenÃ¡rio")
    steps: List[str] = Field(..., description="Lista de passos do cenÃ¡rio")
    scenario_type: str = Field(default="positive", description="Tipo do cenÃ¡rio")
```

#### **Testing Strategy Pattern**
```python
# PadrÃ£o: Mock OpenAI com response structure especÃ­fica
mock_client.chat.completions.create.return_value = Mock(
    choices=[Mock(message=Mock(content="CenÃ¡rio BDD exemplo"))],
    usage=Mock(prompt_tokens=100, completion_tokens=200)
)
```

### **Naming and Documentation**

#### **File Naming Convention**
- **snake_case**: generator.py, openai_client.py, conftest.py
- **Descriptive**: Nomes que indicam responsabilidade clara

#### **Class/Method Naming**
- **Classes**: PascalCase + Descriptive (BDDGenerator, OpenAIClientWrapper)
- **Methods**: snake_case + verb_noun (generate_scenarios, create_completion)
- **Private**: Single underscore (_create_system_prompt, _parse_scenarios)

#### **Docstring Pattern (Google Style)**
```python
def generate_scenarios(
    self,
    user_story: str,
    num_scenarios: int = 3,
) -> BDDResponse:
    """Gera cenÃ¡rios BDD a partir de uma histÃ³ria do usuÃ¡rio.

    Args:
        user_story: HistÃ³ria do usuÃ¡rio em linguagem natural
        num_scenarios: NÃºmero de cenÃ¡rios a gerar

    Returns:
        BDDResponse com os cenÃ¡rios gerados

    Raises:
        Exception: Se houver erro na chamada da API
    """
```

---

## ğŸš€ **DecisÃµes Arquiteturais EspecÃ­ficas**

### **DA001 - Streamlit over FastAPI**
**DecisÃ£o**: Usar Streamlit para MVP ao invÃ©s de FastAPI  
**RazÃ£o**: Prototipagem rÃ¡pida, foco em UX, menos cÃ³digo boilerplate  
**Trade-off**: Single-user sessions vs. multi-user scalability

### **DA002 - OpenAI over Local Models**
**DecisÃ£o**: IntegraÃ§Ã£o direta com OpenAI API  
**RazÃ£o**: Qualidade superior, menor complexidade de infra  
**Trade-off**: DependÃªncia externa vs. controle total

### **DA003 - Pydantic for All Models**
**DecisÃ£o**: Usar Pydantic para toda validaÃ§Ã£o de dados  
**RazÃ£o**: Type safety, documentaÃ§Ã£o automÃ¡tica, JSON serialization  
**Impact**: Zero tolerance para dados nÃ£o tipados

### **DA004 - No Database in MVP**
**DecisÃ£o**: AplicaÃ§Ã£o stateless sem persistÃªncia  
**RazÃ£o**: Simplicidade, deploy fÃ¡cil, foco em core features  
**Future**: Database serÃ¡ adicionado em versÃµes futuras

---

## ğŸ”§ **ConfiguraÃ§Ãµes Preferidas**

### **Development Workflow**
- **Poetry** para dependency management (nÃ£o pip)
- **Black** line-length=88 (padrÃ£o do projeto)
- **MyPy** strict mode obrigatÃ³rio
- **Pytest** com coverage â‰¥85%

### **Code Style Preferences**
- **Portuguese docstrings** para domÃ­nio especÃ­fico
- **English code/variables** para padrÃµes tÃ©cnicos
- **Structured logging** com contexto
- **Exception re-raising** apÃ³s logging

### **UI/UX Preferences**
- **Wide layout** Streamlit para aproveitar espaÃ§o
- **Emoji icons** para visual feedback (ğŸ§ª, âœ…, âŒ, ğŸ¤–)
- **Real-time validation** ao invÃ©s de submit validation
- **Portuguese interface** para usuÃ¡rio brasileiro

---

## ğŸ“Š **Performance Patterns**

### **OpenAI API Optimization**
- **Timeout**: 30s default (nÃ£o muito baixo, nÃ£o muito alto)
- **Max tokens**: 2000 (suficiente para cenÃ¡rios BDD)
- **Temperature**: 0.3 default (criatividade controlada)

### **UI Response Patterns**
- **st.spinner** para operaÃ§Ãµes >1s
- **Session state** para evitar re-computaÃ§Ã£o
- **Caching strategy** planejada para futuro

---

## ğŸ¯ **Evolution Guidelines**

### **When Adding Features**
1. **Manter separaÃ§Ã£o** UI vs. Logic vs. Integration
2. **Usar Pydantic** para novos data models
3. **Documentar em portuguÃªs** aspectos de negÃ³cio
4. **Testar com mock** para componentes externos

### **When Refactoring**
1. **Preservar interfaces** pÃºblicas existentes
2. **Manter backward compatibility** quando possÃ­vel
3. **Documentar breaking changes** no memory bank

### **Future Architecture Evolution**
1. **FastAPI backend** quando escalabilidade for necessÃ¡ria
2. **Database layer** quando persistÃªncia for crÃ­tica
3. **Auth system** quando multi-user for implementado
4. **Cache layer** quando performance for gargalo

---

**ğŸ¯ IMPORTANTE**: Estes padrÃµes foram descobertos atravÃ©s da anÃ¡lise da base de cÃ³digo existente em 2025-08-27. Eles refletem as decisÃµes e preferÃªncias jÃ¡ implementadas pelo desenvolvedor Rafael Pelizza.
