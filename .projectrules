# üéØ Project Rules - BDD Agent

**√öltima atualiza√ß√£o:** 2024-12-19 14:30:00

---

## üêç **Python Standards**

### **Code Style:**
- **PEP 8** compliance obrigat√≥rio
- **Line length:** 88 caracteres (Black standard)
- **Imports:** Organizados por isort (stdlib, third-party, local)
- **Type hints:** Obrigat√≥rios em todas as fun√ß√µes p√∫blicas
- **Docstrings:** Formato Google para todas as fun√ß√µes/classes p√∫blicas

### **Naming Conventions:**
```python
# Classes: PascalCase
class BDDGenerator:
    pass

# Functions/Variables: snake_case
def generate_bdd_scenarios():
    user_input = "example"

# Constants: UPPER_SNAKE_CASE
DEFAULT_MODEL = "gpt-4o-mini"

# Private: _leading_underscore
def _internal_helper():
    pass
```

### **Error Handling:**
```python
# Custom exceptions hierarchy
class BDDAgentError(Exception):
    """Base exception"""
    pass

class ConfigurationError(BDDAgentError):
    """Configuration related errors"""
    pass

# Always use specific exceptions
raise ConfigurationError("API key not configured")
# Never: raise Exception("error")
```

---

## üèóÔ∏è **Architecture Rules**

### **Module Structure:**
- **Single Responsibility:** Cada m√≥dulo tem uma responsabilidade clara
- **Dependency Injection:** Evitar depend√™ncias hardcoded
- **Interface Segregation:** Interfaces pequenas e espec√≠ficas
- **No Circular Imports:** Estrutura hier√°rquica clara

### **Layer Dependencies:**
```
UI Layer (Streamlit)
    ‚Üì
Business Layer (BDD Generator, Auth)
    ‚Üì
Data Layer (Config, Session)
    ‚Üì
Utils Layer (Exceptions, Validators)
```

### **File Organization:**
```python
# Order within files:
1. Module docstring
2. Imports (stdlib, third-party, local)
3. Constants
4. Type definitions
5. Classes
6. Functions
7. Main execution (if __name__ == "__main__")
```

---

## üß™ **Testing Rules**

### **Coverage Requirements:**
- **Minimum:** 80% code coverage
- **Critical paths:** 100% coverage (auth, BDD generation)
- **Test types:** Unit (70%), Integration (25%), E2E (5%)

### **Test Structure:**
```python
# Test naming: test_[function]_[scenario]_[expected]
def test_generate_bdd_valid_input_returns_scenarios():
    # Arrange
    generator = BDDGenerator(mock_client, mock_config)
    user_input = "User wants to login"
    
    # Act
    result = generator.generate_bdd(user_input)
    
    # Assert
    assert len(result.scenarios) > 0
    assert "Given" in result.scenarios[0]
```

### **Mocking Strategy:**
- **External APIs:** Always mocked (OpenAI)
- **File system:** Mocked in unit tests
- **Database:** Use in-memory or fixtures
- **Time:** Mock datetime for deterministic tests

---

## üîí **Security Rules**

### **API Key Management:**
```python
# ‚úÖ Correct
api_key = st.session_state.get('openai_api_key', '')
if not api_key:
    st.error("API key required")
    return

# ‚ùå Never
api_key = "sk-hardcoded-key"  # Never hardcode
print(f"Using key: {api_key}")  # Never log keys
```

### **Input Validation:**
```python
# Always validate user input
from pydantic import BaseModel, validator

class UserInput(BaseModel):
    text: str
    
    @validator('text')
    def validate_text(cls, v):
        if not v.strip():
            raise ValueError('Text cannot be empty')
        if len(v) > 2000:
            raise ValueError('Text too long')
        return v.strip()
```

### **Authentication:**
- **Session-based:** Use st.session_state for auth state
- **No plaintext passwords:** Even for demo (use hashing)
- **Timeout:** Implement session timeout
- **Route protection:** Decorator pattern for protected pages

---

## üé® **Streamlit Rules**

### **State Management:**
```python
# ‚úÖ Centralized state management
class SessionManager:
    def __init__(self):
        self.state = st.session_state
    
    def get(self, key: str, default=None):
        return self.state.get(key, default)
    
    def set(self, key: str, value):
        self.state[key] = value

# ‚ùå Direct session_state access scattered
st.session_state.user_data = data  # Avoid
```

### **Page Structure:**
```python
# Standard page template
def render_page():
    # 1. Authentication check
    if not is_authenticated():
        st.error("Access denied")
        return
    
    # 2. Page header
    st.title("Page Title")
    
    # 3. Main content
    render_main_content()
    
    # 4. Footer/actions
    render_actions()
```

### **Component Rules:**
- **Reusable components:** Create functions for repeated UI elements
- **State isolation:** Components shouldn't directly modify global state
- **Error boundaries:** Handle errors gracefully with st.error()
- **Loading states:** Show progress for long operations

---

## üì¶ **Dependency Rules**

### **Poetry Management:**
```toml
# Group dependencies logically
[tool.poetry.dependencies]
python = "^3.9"
streamlit = "^1.28.0"  # Pin major versions

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
black = "^23.9.0"

[tool.poetry.group.test.dependencies]
pytest-cov = "^4.1.0"
```

### **Import Rules:**
```python
# Order: stdlib, third-party, local
import os
import sys
from datetime import datetime

import streamlit as st
from openai import OpenAI
from pydantic import BaseModel

from src.config.settings import AppConfig
from src.utils.exceptions import BDDAgentError
```

---

## üìö **Documentation Rules**

### **Docstring Format (Google Style):**
```python
def generate_bdd(self, user_input: str) -> BDDResponse:
    """Generate BDD scenarios from user input.
    
    Args:
        user_input: Natural language description of the feature.
        
    Returns:
        BDDResponse containing generated scenarios and metadata.
        
    Raises:
        ConfigurationError: If OpenAI API key is not configured.
        OpenAIError: If API call fails.
        
    Example:
        >>> generator = BDDGenerator(client, config)
        >>> response = generator.generate_bdd("User login")
        >>> print(response.scenarios[0])
        Given a user wants to login...
    """
```

### **README Structure:**
1. **Project description**
2. **Installation instructions**
3. **Usage examples**
4. **Configuration**
5. **Development setup**
6. **Contributing guidelines**
7. **License**

---

## üîç **Code Review Rules**

### **Before Commit:**
```bash
# Run quality checks
poetry run black src tests
poetry run isort src tests
poetry run flake8 src tests
poetry run mypy src
poetry run pytest --cov=src
```

### **Commit Messages:**
```
# Format: type(scope): description
feat(auth): add session timeout functionality
fix(bdd): handle empty API responses
docs(readme): update installation instructions
test(generator): add integration tests for OpenAI
refactor(ui): extract reusable components
```

### **Pull Request Checklist:**
- [ ] Tests pass (pytest)
- [ ] Coverage ‚â• 80%
- [ ] Linting passes (flake8)
- [ ] Type checking passes (mypy)
- [ ] Documentation updated
- [ ] No hardcoded secrets
- [ ] Error handling implemented

---

## üöÄ **Performance Rules**

### **Streamlit Optimization:**
```python
# ‚úÖ Cache expensive operations
@st.cache_data
def load_model_config():
    return load_config_from_file()

# ‚úÖ Use session state for persistence
if 'bdd_cache' not in st.session_state:
    st.session_state.bdd_cache = {}

# ‚ùå Avoid recreating objects
# Don't create new OpenAI client on every request
```

### **API Usage:**
- **Rate limiting:** Implement delays between API calls
- **Caching:** Cache responses for identical inputs
- **Timeouts:** Set reasonable timeouts for API calls
- **Error retry:** Implement exponential backoff

---

## üéØ **BDD-Specific Rules**

### **Gherkin Generation:**
```python
# Standard BDD template
BDD_SYSTEM_PROMPT = """
You are a BDD expert. Generate Gherkin scenarios using:
- Given: Initial context/preconditions
- When: Action/event that triggers behavior
- Then: Expected outcome/result

Format:
Scenario: [Descriptive name]
  Given [context]
  When [action]
  Then [expected result]
"""
```

### **Quality Criteria:**
- **Scenarios:** Must have Given-When-Then structure
- **Language:** Clear, business-friendly language
- **Specificity:** Concrete examples, not abstract descriptions
- **Testability:** Each scenario should be testable

---

## üîß **Development Workflow**

### **Feature Development:**
1. **Create task** in memory-bank/tasks/
2. **Write tests** first (TDD approach)
3. **Implement** minimum viable solution
4. **Refactor** for quality and performance
5. **Update documentation**
6. **Run quality checks**
7. **Update memory-bank**

### **Branch Strategy:**
- **main:** Production-ready code
- **develop:** Integration branch
- **feature/xxx:** Feature development
- **hotfix/xxx:** Critical fixes

---

**Enforcement:** Automated via pre-commit hooks and CI/CD
**Updates:** Rules evolve with project needs
**Compliance:** Mandatory for all code contributions